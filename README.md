# 🎟️ CONCERT MANIA - 콘서트 예약 시스템 백엔드

## 1. 프로젝트 개요

### 본 프로젝트 CONCERT MANIA는 실질적인 콘서트 예매 환경에서 발생하는 대규모 트래픽 및 동시성 문제를 효과적으로 관리하는 것을 목적으로 개발된 고가용성 콘서트 
### 티켓 예약 플랫폼의 백엔드 시스템입니다. 이 시스템은 대규모 동시 사용자 접속으로 인한 경쟁 조건(Race Condition) 하에서의 좌석 선점, 데이터 정합성 보장, 
### 외부 결제 시스템과의 연동 및 분산 트랜잭션의 안정적 처리와 같이, 실무적 관점에서 요구되는 복합적인 기술적 난제들을 Spring Boot 프레임워크를 기반으로 
### 해결하는 것을 핵심 목표로 설정하였습니다.

---

## 주요 기능

* 사용자 인증: JWT 기반의 토큰 인증 및 Spring Security를 통한 인가 처리

* 콘서트/좌석 관리: 콘서트 정보 및 장소별 좌석 등급/가격 관리

* 실시간 좌석 예매: 동시성 제어를 통한 좌석의 실시간 조회 및 선점

* 좌석 임시 점유 및 결제: 좌석 선택 후 10분 내 결제를 완료해야 하는 비즈니스 로직 구현

* 대기열 시스템: 예매 오픈 시 동시 접속자를 제어하기 위한 대기열 로직

* 이벤트 기반 알림: 예약 및 결제 완료 시 Kafka를 통한 비동기 알림 처리

---

## 기술 스택

* Language: Java 17
* Framework: Spring Boot 3.5.3
* Database: MySQL, Spring Data JPA
* 캐싱: Redis, Caffeine
* 메시징: Kafka
* 인증/인가: Spring Security, JWT
* API 문서: Swagger (OpenAPI 3.0)
* 테스트: JUnit 5, MockMvc, Spring Security Test
* 컨테이너: Docker, Docker Compose
* 모니터링: Micrometer, ELK 스택 (Elasticsearch, Logstash, Kibana), APM

---

## 아키텍처 및 설계

* 모놀리식 + DDD 스타일 패키지 구조 적용하여 도메인 응집도를 높이고 결합도를 낮추는 방향으로 설계
* 도메인 별 책임 분리하여 발생하는 단점인 코드의 복잡도를 줄이기 위해 메시지로 이벤트를 발행하고 비동기 처리
* 동시성 제어를 위한 비관적 락 및 Redis 분산 락 병행 적용
* SAGA 패턴을 통한 결제 실패 시 좌석 점유 보상 트랜잭션 처리
* 성능 최적화 (멀티레벨캐싱, Fetch Join)

---

## 기술적 의사결정

### 1. 사용동시성 제어

예상되는 상황 : 수천, 수만 명의 사용자가 밀리초의 단위로 동일한 좌석을 동시에 요청할 수 있습니다. 일반적인 프로세스로는 동일 좌석이 여러 
사용자에게 중복으로 예약되는 데이터 부정합이 발생하고, 후 처리에 더 시간을 많이 쏟는 문제가 발생할 수 있습니다.

#### 해결전략 : 

##### 1. 비관적 락 (DB Level) 

- 데이터 정합성에 있어서 충돌 발생후 롤백하고 재시도 하는 낙관적 락보다 처음부터 자원을 점유하는게 사용자에게 미리 알려줄 수 있어 더 효과적이라고 판단 했습니다.
- JPA의 `LockModeType.PESSIMISTIC_WRITE` 를 사용하여 `Concert` 애그리거트를 조회하는 시점에 `SELECT ... FOR UPDATE` 쿼리를 통해 1개 row에 락을 설정했습니다.

##### 2. 분산 락 (Global Cache Level)

- 사용자가 버튼을 여러번 누르거나, 매크로를 활용할 경우를 생각해 Redis 를 보조적으로 선택했습니다. DB 접근 전에 락을 하게 되어있어 DB부하를 줄이는 효과도 있습니다.
- Redisson 라이브러리를 활용해 사용자 ID로 락을 설정하고, 락을 획득한 요청만 실제 예약 로직을 수행하도록 구현했습니다.

### 2. 분산된 트랜잭션 관리

예상되는 상황 : 좌석 예약과 결제는 독립적으로 처리되어야 하는 트랜잭션이며, 마이크로 서비스 아키텍처가 될 경우 분리될 가능성이 매우 높습니다. 그리고 외부 PG사와의 연동 문제는 
생각보다 빈번하게 일어납니다. 좌석은 예약 되었으나 결제가 실패하여 좌석이 PENDING 상태로 아무도 결제하지 못하는 문제가 발생할 수 있습니다.

#### 해결전략 : 이벤트 기반 SAGA 패턴

- 두 개 이상의 분산된 서비스를 하나의 논리적인 트랜잭션으로 묵기 위해 SAGA 패턴을 도입했습니다. 각 서비스는 자신의 로컬 트랜잭션을 수행하고, 성공 시 다음 단계를 진행시키는 이벤트를 발행합니다. 실패시에는 이를 보상하는 트랜잭션을 수행하고 전파합니다.
- 자리 선점 성공 -> 자리 선점 성공 트랜잭션 전파 -> 결제 시도 -> 결제 성공 -> 결제 성공 트랜잭션 전파 
- 자리 선점 성공 -> 자리 선점 성공 트랜잭션 전파 -> 결제 시도 -> 결제 실패 -> 결제 성공 트랜잭션 전파 -> (내부 정책 : retry 초과 후) 환불 + 자리 선점 취소 

### 3. 성능 최적화
예상되는 상황 : 콘서트 예매 오픈 시작 전 부터 조회 트래픽이 몰리기 시작하고, 예매 오픈하자마자 좌석 현황을 조회하는 API에 트래픽이 집중되어 DB에 과도한 부하가 발생할 것으로 예상됩니다.

#### 해결 전략 : 멀티 레벨 캐싱

- L1 캐시 : 로컬 캐시 (Caffeine) : I/O가 가장 빠른 내부 메모리 캐싱으로서 자주 조회되는 콘서트의 기본 정보 등에 적용이 적합합니다.
- L2 캐시 : 글로벌 캐시 (Redis) : 실시간으로 변동되는 좌석 정보를 캐싱하고, 좌석 정보 변경 시 `@CacheEvict` 를 통해 해당 캐시를 무효화 하여 데이터 정합성을 유지하려고 합니다.

#### 해결 전략 : N+1 해결

- Fetch Join : JPA 사용시 제일 비번하게 발생하는 성능 저하 요인으로 목록 조회 기능에서 JOIN FETCH를 사용했습니다. 
- DTO 프로젝션 : Repository에서 필요한 데이터만 DTO로 직접 조회하게 하여, 영속성 컨텍스트를 거치지 않아 성능에 더 유리하게 만들 수 있습니다. 메서드명 : `findReservationSummariesByUserId`



---
## 실행 방법

### 1. 환경 준비

* Docker, Docker Compose 설치
* `docker-compose.yml` 파일로 MySQL, Kafka, Redis 등 인프라 컨테이너 실행

```bash
docker-compose up -d
```

### 2. 애플리케이션 빌드 및 실행

```bash
./gradlew clean build
java -jar build/libs/concertmania.jar
```

### 3. API 문서 확인

Swagger UI 접속:

```
http://localhost:8080/swagger-ui.html
```

---

## 주요 API 예시

* `POST /api/users/signup` : 회원가입
* `POST /api/users/login` : 로그인 (JWT 발급)
* `GET /api/concerts` : 콘서트 리스트 조회
* `POST /api/v1/concerts/{concertId}/reservations` : 좌석 임시 점유 및 예약 신청
* `POST /api/payments` : 결제 요청

(자세한 API 명세는 Swagger UI 참고)

---




## 기타

* 결제 실패 시 SAGA 패턴으로 좌석 점유 자동 해제 및 예약 취소 처리
* Redis와 Caffeine 캐싱 병행 적용으로 성능 최적화
* Kafka를 활용한 이벤트 기반 아키텍처 및 알림 처리